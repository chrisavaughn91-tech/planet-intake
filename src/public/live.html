<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Planet Lead Pull ‚Äî Live</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    /* ===== Base layout (theme-agnostic) ===== */
    * { box-sizing: border-box }
    html, body { height: 100%; overflow-x: hidden; } /* stop flicker */
    body {
      margin: 0;
      font: 14px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI, Inter, Roboto, Helvetica, Arial;
      color: var(--fg);
      background: var(--bg);
    }

    header {
      position: sticky; top: 0; z-index: 50;
      background: var(--hdr-bg);
      backdrop-filter: blur(6px);
      border-bottom: 1px solid var(--line);
      box-shadow: 0 6px 16px rgba(0,0,0,.25);
    }
    .top {
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
    }
    .brand { font-weight: 800; letter-spacing: .4px }
    .ops   { font-size: 12px; color: var(--muted) }
    .spacer{ flex:1 }

    .pill {
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius: 10px; font-size: 12px;
      border:1px solid var(--chip-b); background: var(--chip);
      text-transform: uppercase; letter-spacing:.04em;
      user-select: none;
    }
    /* "Connected" look (no border, transparent) */
    .pill.link {
      border: none; background: transparent; padding: 0 2px; text-transform: none;
      color: var(--muted);
    }
    .pill.link strong { color: var(--fg); font-weight: 700 }
    .dot { width:8px; height:8px; border-radius:999px; background: var(--ok) }

    /* pulsing link indicator when connected */
    #linkLed.ok .dot {
      animation: dotPulse 1600ms ease-in-out infinite;
      box-shadow: 0 0 0 0 color-mix(in oklab, var(--ok) 70%, transparent);
    }
    @keyframes dotPulse {
      0%   { transform: scale(1);   box-shadow: 0 0 0 0 color-mix(in oklab, var(--ok) 40%, transparent); }
      70%  { transform: scale(1.15); box-shadow: 0 0 0 8px transparent; }
      100% { transform: scale(1);   box-shadow: 0 0 0 0 transparent; }
    }

    .toolbar {
      display:flex; flex-wrap: wrap; gap:8px; align-items:center;
      padding: 0 12px 10px 12px;
    }
    .chip {
      display:inline-flex; align-items:center; gap:6px;
      padding:5px 10px; border-radius:8px; font-size:12px;
      border:1px solid var(--chip-b); background:var(--chip);
      text-transform:uppercase; letter-spacing:.04em; cursor:pointer;
    }
    .chip[data-on="false"] { opacity:.35; filter:saturate(.7) }
    .chip .dot.info    { background: var(--c-info) }
    .chip .dot.start   { background: var(--c-start) }
    .chip .dot.lead    { background: var(--c-lead) }
    .chip .dot.numbers { background: var(--c-num) }
    .chip .dot.badge   { background: var(--c-badge) }
    .chip .dot.sheet   { background: var(--c-sheet) }
    .chip .dot.error   { background: var(--c-err) }
    .chip .dot.done    { background: var(--c-done) }
    .chip .dot.client  { background: var(--muted) }

    .input {
      padding:8px 10px; min-width:280px;
      border-radius:8px; border:1px solid var(--chip-b); background: var(--input);
      color:var(--fg); font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }
    .btn { padding:6px 10px; border-radius:8px; border:1px solid var(--chip-b); background:var(--chip); cursor:pointer; color:var(--fg); }

    /* Running badge totals */
    .stats {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px; color: var(--muted);
      display:flex; align-items:center; gap:12px;
      padding: 0 12px 8px 12px;
    }
    .stats .sep { opacity:.35 }
    .stats strong { color: var(--fg); font-weight:600 }

    /* log area */
    .wrap { padding: 12px }
    .panel {
      border:1px solid var(--line);
      border-radius:12px;
      background: var(--panel);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
      padding: 8px 12px;
      min-height: calc(100dvh - 160px);
    }

    /* Group wrapper for each lead run: lead -> ... -> badge */
    .group {
      margin: 6px 0 10px;
      padding: 2px 8px 6px 8px;
      border-radius: 10px;
      background: linear-gradient(180deg, transparent 0, rgba(255,255,255,.02) 30%, transparent 100%);
    }

    #log .row {
      position: relative;
      display:grid; grid-template-columns: 98px 1fr; gap:12px; align-items:start; /* hide event key column */
      padding:10px 0;
    }
    .time { color: var(--time); font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .type { display:none } /* keep in DOM for filtering, but not visible */
    .pill-badge { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--chip-b); background:var(--chip); color:var(--muted); font-size:11px }
    .msg  { white-space: pre-wrap }

    a.link { color: var(--c-sheet); text-decoration: none; border-bottom:1px dashed var(--c-sheet) }
    a.link:hover { text-decoration: underline }

    /* --------- Newest row sheen UNDERLINE (pulse) --------- */
    #log .row.newest::after{
      content:"";
      position:absolute; left:0; right:0; bottom:-2px; height:2px;
      background:
        linear-gradient(90deg,
          transparent 0%,
          color-mix(in oklab, var(--c-info) 0%, transparent) 30%,
          color-mix(in oklab, var(--c-info) 75%, transparent) 50%,
          color-mix(in oklab, var(--c-info) 0%, transparent) 70%,
          transparent 100%);
      opacity:.85;
      filter: blur(.2px);
      animation: sheenPulse 1600ms ease-in-out infinite;
    }
    @keyframes sheenPulse {
      0%   { opacity: .10; transform: translateX(-3%); }
      50%  { opacity: .90; transform: translateX(0%); }
      100% { opacity: .10; transform: translateX(3%); }
    }

    /* ===== THEMES (switch by body class) ===== */
    /* Aurora: modern dark/blue with faint spinning light (no overflow) */
    .t-aurora {
      --bg: #0b0f12;
      --panel: linear-gradient(180deg, #0e1317, #0b1014);
      --hdr-bg: rgba(11,15,18,.9);
      --fg:#e8eef6; --muted:#9fb0c2;
      --line:#1e2a34; --chip:#0f151b; --chip-b:#20303a; --input:#0e1419;
      --time:#b9c7d6;
      --c-info:#86b7ff; --c-start:#ffd27a; --c-lead:#a8ff8a; --c-num:#80ffc8; --c-badge:#f6b4ff; --c-sheet:#9ff2ff; --c-err:#ff7b7b; --c-done:#8ef0c9; --ok:#8fffa0;
    }
    .t-aurora::before {
      content:""; position:fixed; inset:0; pointer-events:none; mix-blend-mode:soft-light; opacity:.30;
      background: conic-gradient(from 0deg, rgba(80,180,255,.15), transparent 25%, rgba(120,255,170,.12), transparent 55%, rgba(255,220,120,.12), transparent 85%);
      filter: blur(22px);
      transform: scale(1.35);
      animation: neb 14s linear infinite;
    }
    @keyframes neb { to { transform: scale(1.35) rotate(360deg) } }

    /* Neon HUD */
    .t-neon {
      --bg:#070b08; --panel: linear-gradient(180deg,#0a120e,#08100c);
      --hdr-bg: rgba(10,18,14,.9);
      --fg:#e7f3ea; --muted:#9aa69f; --line:#223429; --chip:#0d1611; --chip-b:#244033; --input:#0c1611; --time:#b7c5bb;
      --c-info:#8fffa0; --c-start:#ffd27a; --c-lead:#baff7e; --c-num:#80ffd1; --c-badge:#ffd2ff; --c-sheet:#9ff2ff; --c-err:#ff8b8b; --c-done:#8ef0c9; --ok:#8fffa0;
    }
    .t-neon::before {
      content:""; position:fixed; inset:0; pointer-events:none; opacity:.35;
      background:
        linear-gradient(180deg, rgba(255,255,255,.04) 1px, transparent 1px) 0 0/100% 3px,
        repeating-linear-gradient(0deg, transparent 0, transparent 22px, rgba(255,255,255,.028) 23px);
    }

    /* Matrix */
    .t-matrix {
      --bg:#050805; --panel: linear-gradient(180deg,#071007,#060d06);
      --hdr-bg: rgba(6,12,7,.9);
      --fg:#d5f7d5; --muted:#8cab8c; --line:#103314; --chip:#0a160b; --chip-b:#1a3a1d; --input:#0a150b; --time:#99c699;
      --c-info:#7cff8f; --c-start:#c9ff72; --c-lead:#99ff66; --c-num:#66ffc2; --c-badge:#b3ffb3; --c-sheet:#66ffe0; --c-err:#ff6b6b; --c-done:#8ef0c9; --ok:#80ff99;
    }
    .t-matrix::before {
      content:""; position:fixed; inset:0; pointer-events:none; opacity:.2;
      background:
        radial-gradient(1200px 800px at 15% -10%, rgba(0,255,120,.10), transparent 60%),
        radial-gradient(1000px 900px at 110% 120%, rgba(0,180,120,.07), transparent 60%),
        repeating-linear-gradient(0deg, rgba(0,255,120,.04) 0 1px, transparent 1px 3px);
    }
    .t-matrix::after {
      content:""; position:fixed; inset:0; pointer-events:none; opacity:.07;
      background: repeating-linear-gradient(90deg, rgba(0,255,100,.35) 0 1px, transparent 1px 18px);
      mix-blend-mode: soft-light;
    }

    /* Light */
    .t-light {
      --bg:#f8fafc; --panel:#ffffff; --hdr-bg:#ffffffcc;
      --fg:#0f172a; --muted:#475569; --line:#d4dbe3; --chip:#f1f5f9; --chip-b:#d7dee6; --input:#ffffff; --time:#334155;
      --c-info:#2563eb; --c-start:#b45309; --c-lead:#15803d; --c-num:#0e7490; --c-badge:#7c3aed; --c-sheet:#0ea5e9; --c-err:#b91c1c; --c-done:#047857; --ok:#16a34a;
    }

    /* ensure readability on all themes */
    #log, #log .row, #log .row * { mix-blend-mode: normal; filter: none; color: var(--fg) }
  </style>
</head>
<body class="t-aurora">

  <header>
    <div class="top">
      <div class="brand">OP: PLANET LEAD PULL</div>
      <div class="ops">Live Feed</div>
      <div class="spacer"></div>

      <!-- moved right; no border; says Connected -->
      <span id="linkLed" class="pill link" title="connection">
        <span class="dot" id="connDot" aria-hidden="true"></span> <strong>Connected</strong>
      </span>
    </div>

    <!-- Running badge totals + premium total -->
    <div class="stats" id="stats">
      <span id="badgeRun">‚≠ê 0 (0%) üü£ 0 (0%) üü† 0 (0%) üî¥ 0 (0%) ‚ö™ 0 (0%)</span>
      <span class="sep">|</span>
      <span id="premRun">$0.00 total</span>
    </div>

    <div class="toolbar" id="toolbar">
      <!-- chips kept for filtering; UI stays -->
      <label class="chip" data-key="info"    data-on="true"><span class="dot info"></span>info</label>
      <label class="chip" data-key="start"   data-on="true"><span class="dot start"></span>start</label>
      <label class="chip" data-key="lead"    data-on="true"><span class="dot lead"></span>lead</label>
      <label class="chip" data-key="numbers" data-on="true"><span class="dot numbers"></span>numbers</label>
      <label class="chip" data-key="badge"   data-on="true"><span class="dot badge"></span>badge</label>
      <label class="chip" data-key="sheet"   data-on="true"><span class="dot sheet"></span>sheet</label>
      <label class="chip" data-key="error"   data-on="true"><span class="dot error"></span>error</label>
      <label class="chip" data-key="done"    data-on="true"><span class="dot done"></span>done</label>
      <label class="chip" data-key="client"  data-on="false"><span class="dot client"></span>client</label>

      <div class="spacer"></div>
      <input id="q" class="input" placeholder="Filter text (e.g. jobId, sheet:url)" />
      <!-- order swapped: Clear then Auto-scroll -->
      <button id="clearBtn" class="btn">Clear</button>
      <label class="chip" id="autoScroll" data-on="true" title="Auto-scroll on new messages"><span class="dot info"></span>Auto-scroll</label>
    </div>
  </header>

  <div class="wrap">
    <div class="panel">
      <div id="log"></div>
    </div>
  </div>

  <script>
    /* ---------- UI refs ---------- */
    const logEl = document.getElementById('log');
    const toolbar = document.getElementById('toolbar');
    const inputQ = document.getElementById('q');
    const autoScrollChip = document.getElementById('autoScroll');
    const connDot = document.getElementById('connDot');
    const linkLed = document.getElementById('linkLed');

    // running totals
    const badgeRunEl = document.getElementById('badgeRun');
    const premRunEl  = document.getElementById('premRun');

    /* ---------- filters ---------- */
    const filters = new Map([...toolbar.querySelectorAll('.chip[data-key]')].map(ch => [ch.dataset.key, ch.dataset.on === 'true']));
    toolbar.addEventListener('click', (e)=>{
      const ch = e.target.closest('.chip[data-key]');
      if (!ch) return;
      ch.dataset.on = ch.dataset.on === 'true' ? 'false' : 'true';
      filters.set(ch.dataset.key, ch.dataset.on === 'true');
      refilter();
    });
    autoScrollChip.addEventListener('click', ()=> {
      autoScrollChip.dataset.on = autoScrollChip.dataset.on === 'true' ? 'false' : 'true';
    });
    document.getElementById('clearBtn').onclick = () => { logEl.innerHTML=''; currentGroup = null; };
    inputQ.addEventListener('input', ()=> refilter());

    /* ---------- helpers ---------- */
    const params = new URLSearchParams(location.search);
    const jobId = params.get('job') || null;

    let t0 = null;
    const now = () => performance.now();
    const pad2 = n => String(n).padStart(2,'0');
    const hmsFromMs = (ms) => {
      const s = Math.max(0, Math.floor(ms/1000));
      const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), ss = s%60;
      return (h? h+'h ' : '') + (m? m+'m ' : '') + (ss? ss+'s' : '0s');
    };
    const elapsed = () => {
      if (!t0) return '00:00:00';
      const d = now()-t0;
      const hh = pad2(Math.floor(d/3600000));
      const mm = pad2(Math.floor((d%3600000)/60000));
      const ss = pad2(Math.floor((d%60000)/1000));
      return `${hh}:${mm}:${ss}`;
    };

    // subtle grouping: a <div.group> that holds rows from each lead until the next lead/badge ends it
    let currentGroup = null;
    function startGroup() {
      currentGroup = document.createElement('div');
      currentGroup.className = 'group';
      logEl.appendChild(currentGroup);
    }
    function hostFor(level){
      // group only these: lead / numbers / badge / info (during lead)
      if (level === 'lead') { startGroup(); return currentGroup; }
      if (currentGroup && (level === 'numbers' || level === 'badge' || level === 'info')) return currentGroup;
      return logEl;
    }

    function addRow(level, msg, meta = {}) {
      if (!filters.get(level)) return;

      const q = inputQ.value.trim().toLowerCase();
      if (q && !(`${level} ${JSON.stringify(meta)} ${msg}`.toLowerCase().includes(q))) return;

      // remove "newest" from the previous last row BEFORE appending the new one
      const wasNewest = logEl.querySelector('.row.newest');
      if (wasNewest) wasNewest.classList.remove('newest');

      const row = document.createElement('div');
      row.className = 'row newest';

      const t = document.createElement('div');
      t.className = 'time'; t.textContent = elapsed();

      // keep a hidden type span for filtering (but not visible)
      const ty = document.createElement('div'); ty.className = 'type';
      const lvl = document.createElement('span'); lvl.className = `level-${level}`; lvl.textContent = level;
      ty.append(lvl);

      const m = document.createElement('div');
      m.className = 'msg';
      if (meta.html) { m.innerHTML = meta.html; } else { m.textContent = msg; }

      row.append(t, m, ty); /* order: time | message | (hidden type) */
      hostFor(level).appendChild(row);

      if (autoScrollChip.dataset.on === 'true') { row.scrollIntoView({behavior:'smooth', block:'end'}); }
    }

    function refilter(){
      [...logEl.querySelectorAll('.row')].forEach(row=>{
        const typeEl = row.querySelector('.type .level-info, .level-start, .level-lead, .level-numbers, .level-badge, .level-sheet, .level-error, .level-done, .level-client');
        const typeText = typeEl ? typeEl.textContent : 'info';
        const showType = filters.get(typeText);
        const q = inputQ.value.trim().toLowerCase();
        const showText = !q || row.innerText.toLowerCase().includes(q);
        row.style.display = (showType && showText) ? '' : 'none';
      });
    }

    /* ---------- Running totals (all badges) ---------- */
    let totalBadged = 0;        // leads that produced a 'badge' event
    const counts = { star:0, purple:0, orange:0, red:0, white:0 };
    let premiumTotal = 0;

    function fmtPct(n, d) { return d ? Math.round((n/d)*100) + '%' : '0%'; }
    function renderStats() {
      badgeRunEl.textContent =
        `‚≠ê ${counts.star} (${fmtPct(counts.star,totalBadged)}) ` +
        `üü£ ${counts.purple} (${fmtPct(counts.purple,totalBadged)}) ` +
        `üü† ${counts.orange} (${fmtPct(counts.orange,totalBadged)}) ` +
        `üî¥ ${counts.red} (${fmtPct(counts.red,totalBadged)}) ` +
        `‚ö™ ${counts.white} (${fmtPct(counts.white,totalBadged)})`;
      premRunEl.textContent = `${premiumTotal.toLocaleString(undefined,{style:'currency',currency:'USD'})} total`;
    }
    function classifyBadge(txt){
      const t = (txt||'').toString().toLowerCase();
      if (/[‚≠ê]|star|prem/.test(t)) return 'star';
      if (/purple|üü£/.test(t))     return 'purple';
      if (/orange|üü†/.test(t))     return 'orange';
      if (/red|üî¥/.test(t))        return 'red';
      if (/white|‚ö™|basic/.test(t))return 'white';
      // default: treat as white if unknown
      return 'white';
    }

    /* ---------- SSE ---------- */
    const es = new EventSource(jobId ? `/events?jobId=${encodeURIComponent(jobId)}` : '/events');

    es.addEventListener('open', () => {
      connDot.style.background = 'var(--ok)';
      linkLed.classList.add('ok');            // start pulsing
      if (!t0) t0 = now();
      addRow('info', `stream: connected${jobId ? ` (job ${jobId})` : ''}`);
    });

    es.addEventListener('error', () => {
      linkLed.classList.remove('ok');
      connDot.style.background = 'var(--c-err)';
      addRow('error', 'stream: error (trying to reconnect‚Ä¶)');
    });

    const handlers = {
      info: (d) => {
        if (d && typeof d.msg === 'string' && d.msg.toLowerCase().startsWith('sheet:url')) return;
        addRow('info', d.msg || '');
      },

      start: (d) => { if (!t0) t0 = now(); addRow('start', `max=${d.maxLeads ?? ''}`, d); },

      lead: (d) => {
        let name = d.leadName || d.name || d.msg || '';
        const hashMatch = /^#?(\d+)\s*\/\s*(\d+)\s+(.+)$/i.exec(name);
        if (hashMatch) {
          const [, idx, tot, nm] = hashMatch;
          name = `${nm.trim()} (${idx} of ${tot})`;
        } else if (d.index && d.total && name) {
          name = `${name} (${d.index} of ${d.total})`;
        }
        addRow('lead', name || (d.msg || ''));
      },

      numbers: (d) => addRow('numbers', `listed=${d.listedCount} extras=${d.extraCount} flagged=${d.flaggedCount}`),

      badge: (d) => {
        totalBadged += 1;
        counts[classifyBadge(d.badge)] = (counts[classifyBadge(d.badge)] || 0) + 1;

        if (typeof d.totalPremium === 'number') premiumTotal = d.totalPremium;
        renderStats();

        addRow('badge', `${d.badge || ''} total=${typeof d.totalPremium === 'number' ? d.totalPremium : premiumTotal}`);
      },

      sheet: (d) => {
        if (!d.url) return;
        const html = `sheet: <a class="link" href="${d.url}" target="_blank" rel="noopener">${d.url}</a>`;
        addRow('sheet', '', { html });
      },

      error: (d) => addRow('error', d.msg || ''),

      done: (d) => {
        if (!d || (typeof d.processed === 'number' && d.processed === 0)) return;
        const human = (typeof d.ms === 'number') ? hmsFromMs(d.ms) : '';
        const msg = `${d.processed ?? 0} ${d.processed === 1 ? 'lead' : 'leads'} processed in ${human || '0s'}`;
        addRow('done', msg);
        // end a group after DONE, if one is still open
        currentGroup = null;
      },

      client: (d) => addRow('client', d.msg || '')
    };

    ['info','start','lead','numbers','badge','sheet','error','done','client'].forEach(type=>{
      es.addEventListener(type, (e)=>{
        try{
          const data = JSON.parse(e.data || '{}');
          if (!t0 && type !== 'info') t0 = now();
          (handlers[type] || handlers.info)(data);
        }catch(err){
          addRow('error', 'parse error');
          console.error(err, e?.data);
        }
      });
    });

    // initial stats paint
    renderStats();
  </script>
</body>
</html>
